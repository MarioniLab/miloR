# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

computeYStar <- function(X, curr_beta, Z, Dinv, curr_u, y) {
    .Call('_miloR_computeYStar', PACKAGE = 'miloR', X, curr_beta, Z, Dinv, curr_u, y)
}

computeVmu <- function(mu, r) {
    .Call('_miloR_computeVmu', PACKAGE = 'miloR', mu, r)
}

computeW <- function(Dinv, V) {
    .Call('_miloR_computeW', PACKAGE = 'miloR', Dinv, V)
}

computeVStar <- function(Z, G, W) {
    .Call('_miloR_computeVStar', PACKAGE = 'miloR', Z, G, W)
}

computePREML <- function(Vsinv, X) {
    .Call('_miloR_computePREML', PACKAGE = 'miloR', Vsinv, X)
}

#' GLMM parameter estimation using pseudo-likelihood
#'
#' Iteratively estimate GLMM fixed and random effect parameters, and variance
#' component parameters using Fisher scoring based on the Pseudo-likelihood
#' approximation to a Normal loglihood.
#' @param Z sp_mat - sparse matrix that maps random effect variable levels to
#' observations
#' @param X sp_mat - sparse matrix that maps fixed effect variables to
#' observations
#' @param muvec NumericVector vector of estimated phenotype means
#' @param curr_theta NumericVector vector of initial parameter estimates
#' @param curr_beta NumericVector vector of initial beta estimates
#' @param curr_u NumericVector of initial u estimates
#' @param curr_G NumericVector of initial sigma estimates
#' @param y NumericVector of observed counts
#' @param rlevels List containing mapping of RE variables to individual
#' levels
#' @param curr_disp double Dispersion parameter estimate
#' @param REML bool - use REML for variance component estimation
fitPLGlmm <- function(Z, X, muvec, curr_beta, curr_theta, curr_u, curr_sigma, curr_G, y, u_indices, theta_diff, sigma_diff, theta_conv, rlevels, curr_disp, REML, maxit) {
    .Call('_miloR_fitPLGlmm', PACKAGE = 'miloR', Z, X, muvec, curr_beta, curr_theta, curr_u, curr_sigma, curr_G, y, u_indices, theta_diff, sigma_diff, theta_conv, rlevels, curr_disp, REML, maxit)
}

#' Compute the inverse of a structured covariance matrix
#'
#' Using Henderson's adjusted Woodbury formula for a singular B matrix,
#' compute the inverse of the pseudocovariance matrix ZGZ' + W as
#' (A + UBU^T)^-1 = A^-1 - A^-1UB[I + U^TA^-1UB]^-1U^TA^-1
#'
#' @param A SparseMatrix - a nxn matrix of the GLMM covariance D^-1*V*D^-1
#' @param B SparseMatrix - a cxc matrix of variance components
#' @param Z SparseMatrix - a nxc design matrix that maps REs to samples
invertPseudoVar <- function(A, B, Z) {
    .Call('_miloR_invertPseudoVar', PACKAGE = 'miloR', A, B, Z)
}

#' Compute product of each pseudovariance partial derivatives with the inverse
#' pseudovariance matrix
#'
#' For each variance component, we compute the matrix multiplication of the
#' relevant partial derivative of dV_start/dSigm with the pseudovariance matrix
#'
#' @param List partials - list containing matrices of partial derivatives of the pseudovariance
#' for each variance component
#' @param SparseMatrix psvar_in - inverse of the pseudovariance matrix
multiP <- function(partials, psvar_in) {
    .Call('_miloR_multiP', PACKAGE = 'miloR', partials, psvar_in)
}

sigmaScoreREML <- function(pvstar_i, Vsinv, ystar, P) {
    .Call('_miloR_sigmaScoreREML', PACKAGE = 'miloR', pvstar_i, Vsinv, ystar, P)
}

sigmaInfoREML <- function(pvstari) {
    .Call('_miloR_sigmaInfoREML', PACKAGE = 'miloR', pvstari)
}

sigmaScore <- function(ystar, beta, X, V_partial, V_star_inv) {
    .Call('_miloR_sigmaScore', PACKAGE = 'miloR', ystar, beta, X, V_partial, V_star_inv)
}

sigmaInformation <- function(V_star_inv, V_partial) {
    .Call('_miloR_sigmaInformation', PACKAGE = 'miloR', V_star_inv, V_partial)
}

FisherScore <- function(hess, score_vec, theta_hat) {
    .Call('_miloR_FisherScore', PACKAGE = 'miloR', hess, score_vec, theta_hat)
}

solve_equations <- function(X, Winv, Z, Ginv, beta, u, ystar) {
    .Call('_miloR_solve_equations', PACKAGE = 'miloR', X, Winv, Z, Ginv, beta, u, ystar)
}

#' Compute pseudovariance partial derivatives
#'
#' Compute the partial derivatives of the pseudovariance as t(Z[, i]) %*% Z[, i]
#' for the ith variance component
#'
#' @param Matrix x - the fully expanded Z matrix that maps observations to
#' random effect variables
#' @param List rlevels - a list that maps the random effect variable to the
#' individual levels
#' @param List dimnames - a list of the matrix `x` dimension names.
pseudovarPartial <- function(x, rlevels, cnames) {
    .Call('_miloR_pseudovarPartial', PACKAGE = 'miloR', x, rlevels, cnames)
}

pseudovarPartial_C <- function(Z, u_indices) {
    .Call('_miloR_pseudovarPartial_C', PACKAGE = 'miloR', Z, u_indices)
}

#' Compute the matrix trace
mtrace <- function(x) {
    .Call('_miloR_mtrace', PACKAGE = 'miloR', x)
}

