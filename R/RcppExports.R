# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

computeVStar <- function(Z, G, W) {
    .Call('_miloR_computeVStar', PACKAGE = 'miloR', Z, G, W)
}

#' GLMM parameter estimation using pseudo-likelihood
#'
#' Iteratively estimate GLMM fixed and random effect parameters, and variance
#' component parameters using Fisher scoring based on the Pseudo-likelihood
#' approximation to a Normal loglihood.
#' @param Z mat - sparse matrix that maps random effect variable levels to
#' observations
#' @param X mat - sparse matrix that maps fixed effect variables to
#' observations
#' @param muvec vec vector of estimated phenotype means
#' @param curr_theta vec vector of initial parameter estimates
#' @param curr_beta vec vector of initial beta estimates
#' @param curr_u vec of initial u estimates
#' @param curr_sigma vec of initial sigma estimates
#' @param curr_G mat c X c matrix of variance components
#' @param y vec of observed counts
#' @param u_indices List a List, each element contains the indices of Z relevant
#' to each RE and all its levels
#' @param theta_conv double Convergence tolerance for paramter estimates
#' @param rlevels List containing mapping of RE variables to individual
#' levels
#' @param curr_disp double Dispersion parameter estimate
#' @param REML bool - use REML for variance component estimation
#' @param maxit int maximum number of iterations if theta_conv is FALSE
fitPLGlmm <- function(Z, X, muvec, curr_beta, curr_theta, curr_u, curr_sigma, curr_G, y, u_indices, theta_conv, rlevels, curr_disp, REML, maxit) {
    .Call('_miloR_fitPLGlmm', PACKAGE = 'miloR', Z, X, muvec, curr_beta, curr_theta, curr_u, curr_sigma, curr_G, y, u_indices, theta_conv, rlevels, curr_disp, REML, maxit)
}

#' Compute the inverse of a structured covariance matrix
#'
#' Using Henderson's adjusted Woodbury formula for a singular B matrix,
#' compute the inverse of the pseudocovariance matrix ZGZ' + W as
#' (A + UBU^T)^-1 = A^-1 - A^-1UB[I + U^TA^-1UB]^-1U^TA^-1
#'
#' @param A SparseMatrix - a nxn matrix of the GLMM covariance D^-1*V*D^-1
#' @param B SparseMatrix - a cxc matrix of variance components
#' @param Z SparseMatrix - a nxc design matrix that maps REs to samples
invertPseudoVar <- function(A, B, Z) {
    .Call('_miloR_invertPseudoVar', PACKAGE = 'miloR', A, B, Z)
}

#' Compute product of each pseudovariance partial derivatives with the inverse
#' pseudovariance matrix
#'
#' For each variance component, we compute the matrix multiplication of the
#' relevant partial derivative of dV_start/dSigm with the pseudovariance matrix
#'
#' @param List partials - list containing matrices of partial derivatives of the pseudovariance
#' for each variance component
#' @param SparseMatrix psvar_in - inverse of the pseudovariance matrix
multiP <- function(partials, psvar_in) {
    .Call('_miloR_multiP', PACKAGE = 'miloR', partials, psvar_in)
}

#' Compute pseudovariance partial derivatives
#'
#' Compute the partial derivatives of the pseudovariance as t(Z[, i]) %*% Z[, i]
#' for the ith variance component
#'
#' @param Matrix x - the fully expanded Z matrix that maps observations to
#' random effect variables
#' @param List rlevels - a list that maps the random effect variable to the
#' individual levels
#' @param List dimnames - a list of the matrix `x` dimension names.
pseudovarPartial <- function(x, rlevels, cnames) {
    .Call('_miloR_pseudovarPartial', PACKAGE = 'miloR', x, rlevels, cnames)
}

pseudovarPartial_C <- function(Z, u_indices) {
    .Call('_miloR_pseudovarPartial_C', PACKAGE = 'miloR', Z, u_indices)
}

