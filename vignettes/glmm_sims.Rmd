---
title: "GLMM simulations"
output: html_notebook
---

To road-test and develop the GLMM extension to Milo, we need simulated data where we know the ground-truth and the relevant fixed and random effects. I will 
use a series of different simulations that are based around simulating counts with additional contributions from different factors, such as the randomly 
sampling of individuals that depends on some factor (i.e. random effects), and factors that alter the mean counts (i.e. fixed effects).

I'm still not sure whether to formulate the mixed model as a Gamma-Poisson or a negative binomial + Normally distributed random effects. There are pros and cons 
in favour of either. The dangerous answer is to use both, but that would be a) confusing, and b) an inefficient use of time.  For the moment, and these 
simulations, I'll assume the response variable is generated by a negative binomial process with a normal random effect.

```{r, warning=FALSE, message=FALSE}
library(MASS)
library(Matrix)
library(reshape2)
library(ggplot2)
library(ggthemes)
library(ggsci) 
library(cowplot)
library(glmmTMB)
library(scales)
library(viridis)
library(tidyr)
library(profvis)
library(pbkrtest)
library(lmerTest)
```

```{r}
source("~/Documents/Milo2.0/R_scripts/miloR/R/glmm_new.R")
```

I'll start by writing a function that simulates a data set with N observations. This will be useful for evaluating the consistency of our model over repeated runs.

```{r}
initializeFullZsim <- function(Z, cluster_levels, stand.cols=FALSE){
    # construct the full Z with all random effect levels
    n.cols <- ncol(Z)
    col.classes <- apply(Z, 2, class)
    i.z.list <- list()
    for(i in seq_len(n.cols)){
        i.class <- col.classes[i]
        if(i.class %in% c("factor")){ # treat as factors
            i.levels <- levels(Z[, i, drop=FALSE])
            i.levels <- as.factor(paste(sort(as.integer(i.levels))))
            i.z <- sapply(i.levels, FUN=function(X) (Z[, i] == X) + 0, simplify=TRUE)
        } else if(i.class %in% c("character")){
            i.levels <- unique(Z[, i, drop=FALSE])
            i.levels <- as.factor(paste(sort(as.integer(i.levels))))
            i.z <- sapply(i.levels, FUN=function(X) (Z[, i] == X) + 0, simplify=TRUE)
        } else if(i.class %in% c("numeric")){ # split into unique levels if integer levels
            i.mod <- all(Z[, i, drop=FALSE] %% 1 == 0)
            if(isTRUE(i.mod)){
                i.levels <- unique(Z[, i])
                i.levels <- as.factor(paste(sort(as.integer(i.levels))))
                i.z <- sapply(i.levels, FUN=function(X) (Z[, i] == X) + 0, simplify=TRUE)
            } else{
                i.z <- Z[, i, drop=FALSE] # if float then treat as continuous
            }
        } else if(i.class %in% c("integer")){
            i.levels <- (unique(Z[, i]))
            i.levels <- as.factor(paste(sort(as.integer(i.levels))))
            i.z <- sapply(i.levels, FUN=function(X) (Z[, i] == X) + 0, simplify=TRUE)
        }
        colnames(i.z) <- cluster_levels[[colnames(Z)[i]]]
        
        # to standardise or not?
        if(isTRUE(stand.cols)){
            q <- ncol(i.z)
            i.ident <- diag(1L, nrow=nrow(i.z), ncol=nrow(i.z))
            i.star <- i.z - ((i.ident %*% i.z)/q)
            i.z <- i.star
        }
        
        i.z.list[[colnames(Z)[i]]] <- i.z
    }
    full.Z <- do.call(cbind, i.z.list)
    return(full.Z)
}
```


```{r}
SimulateMMData <- function(N, fe.betas, re.sigmas,
                           dispersion, grand.mean, n.fe, n.re,
                           re.levels,
                           fe.levels){
    # create a per-level mean effect for each FE
    if(length(fe.levels) != n.fe){
        stop("List entries need to match number of input fixed effects")
    }
    
    if(length(re.levels) != n.re){
        stop("List entries need to match number of input random effects")
    }
    
    # create the design matrices
    X <- matrix(0L, ncol=n.fe+1, nrow=N)
    X[, 1] <- 1
    colnames(X) <- c("Intercept", names(fe.levels))
    
    Z <- matrix(0L, ncol=n.re, nrow=N)
    
    for(i in seq_len(n.fe)){
        if(fe.levels[[i]] == 1){
            X[, i+1] <- sapply(seq_len(N), FUN=function(B){
                rnorm(1, mean=0, sd=1)
                })
        } else if(fe.levels[[i]] == 2){
            X[, i+1] <- sapply(seq_len(N), FUN=function(B){
                sample(c(0, 1), 1)
                })
            X[, i+1] <- (X[, i+1]) #removed as.factor
        }else{
            X[, i+1] <- sapply(seq_len(N), FUN=function(B){
                sample(seq_len(fe.levels[[i]]), 1)
                })
            X[, i+1] <- as.factor(X[, i+1])
        }
    }
    
    # Make categorical effects 0 or 1 (not 1 or 2)
    #X[,2] <- X[,2] - 1
    
    for(j in seq_len(n.re)){
        if(re.levels[[j]] == 1){
            Z[, j] <- sapply(seq_len, FUN=function(R){
                rnorm(1, mean=1, sd=1)
            })
        } else{
            Z[, j] <- sapply(seq_len(N), FUN=function(R){
                sample(seq_len(re.levels[[j]]), 1)
            })
            Z[, j] <- factor(Z[, j], levels=c(1:re.levels[[j]]))
        }
    }
    colnames(Z) <- names(re.levels)
    
    # construct the full Z
    random.levels <- sapply(seq_len(length(re.levels)), FUN=function(RX) {
        rx.name <- names(re.levels)[RX]
        paste(rx.name, seq_len(re.levels[[rx.name]]), sep="_")
        }, simplify=FALSE)
    names(random.levels) <- names(re.levels)

    full.Z <- initializeFullZsim(Z, random.levels)
    
    # get a combination over random effects 
    # and sample each level from the same ~Normal(0, sigma)
    # note that the variance would be G if we also had random slopes
    re.thetas <- list()
    for(i in seq_len(length(re.levels))){
        i.re <- names(random.levels[i])
        i.levels <- length(random.levels[[i.re]])
        i.re.means <- rnorm(n=i.levels, 0, sd=sqrt(re.sigmas[[i.re]])) # sample a random effect value
        i.re.list <- sapply(seq_len(i.levels), FUN=function(X) i.re.means[X])
        names(i.re.list) <- random.levels[[i.re]]
        re.thetas[[i.re]] <- i.re.list
    }
    
    B <- full.Z %*% unlist(re.thetas)

    # map the fixed effects to mean values
    betas <- c(grand.mean, unlist(fe.betas))
    Beta <- X %*% betas

    i.error <- matrix(data = rnorm(N, mean=0, sd=0.001), ncol = 1)
    
    # construct the y.means equation, depending on desired distribution and FE/RE
    y.means <- exp(Beta + B) 
    y.means <- y.means #+ i.error

    #theta.disp <- (mu.mu/2) - dispersion
    #y.counts <- rnegbin(n=nrow(y.means), mu=exp(unique.fe.df$Beta), theta=1)
    #theta.disp <- (mean(y.means)/2) - dispersion
    #r <- -dispersion + mean(y.means)/2
    r <- mean(y.means)^2/(mean(y.means)^2/dispersion + 2*mean(y.means))
    y.counts <- rnbinom(N, mu = y.means, size = dispersion)

    sim.data <- data.frame("Mean"=y.means, "Mean.Count"=y.counts, "r"=r)
    sim.data <- do.call(cbind.data.frame, list(sim.data, X, Z))
    return(sim.data)
}

fe.levels <- list("FE1"=2, "FE2"=1)
re.levels <- list("RE1"=10, "RE2"=7)

grand.mean <- 2

fe.betas <- list("FE1"=0.3, "FE2"=0.7)
re.sigmas <- list("RE1"=0.4, "RE2"=0.4)

r.dispersion <- 0.5
set.seed(43)
sim.df <- SimulateMMData(N=1000, fe.betas=fe.betas, re.sigmas=re.sigmas, dispersion=r.dispersion, grand.mean=grand.mean, 
                         n.fe=length(fe.betas), n.re=length(re.sigmas), re.levels=re.levels, fe.levels=fe.levels)

sim.df$FE1 <- as.factor(sim.df$FE1)
sim.df$RE1 <- as.factor(sim.df$RE1)
```

```{r}
# SimulateMMData <- function(N, fe.betas, re.sigmas,
#                            dispersion, grand.mean, n.fe, n.re,
#                            re.levels,
#                            fe.levels){
#     # create a per-level mean effect for each FE
#     if(length(fe.levels) != n.fe){
#         stop("List entries need to match number of input fixed effects")
#     }
#     
#     if(length(re.levels) != n.re){
#         stop("List entries need to match number of input random effects")
#     }
#     
#     # create the design matrices
#     X <- matrix(0L, ncol=n.fe+1, nrow=N)
#     X[, 1] <- 1
#     colnames(X) <- c("Intercept", names(fe.levels))
#     
#     Z <- matrix(0L, ncol=n.re, nrow=N)
#     
#     for(i in seq_len(n.fe)){
#         if(fe.levels[[i]] == 1){
#             X[, i+1] <- sapply(seq_len(N), FUN=function(B){
#                 rnorm(1, mean=0, sd=1)
#                 })
#         } else if(fe.levels[[i]] == 2){
#             X[, i+1] <- sapply(seq_len(N), FUN=function(B){
#                 sample(c(0, 1), 1)
#                 })
#             X[, i+1] <- as.factor(X[, i+1])
#         }else{
#             X[, i+1] <- sapply(seq_len(N), FUN=function(B){
#                 sample(seq_len(fe.levels[[i]]), 1)
#                 })
#             X[, i+1] <- as.factor(X[, i+1])
#         }
#     }
#     
#     # Make categorical effects 0 or 1 (not 1 or 2)
#     X[,2] <- X[,2] - 1
#     
#     for(j in seq_len(n.re)){
#         if(re.levels[[j]] == 1){
#             Z[, j] <- sapply(seq_len, FUN=function(R){
#                 rnorm(1, mean=1, sd=1)
#             })
#         } else{
#             Z[, j] <- sapply(seq_len(N), FUN=function(R){
#                 sample(seq_len(re.levels[[j]]), 1)
#             })
#             Z[, j] <- factor(Z[, j], levels=c(1:re.levels[[j]]))
#         }
#     }
#     colnames(Z) <- names(re.levels)
#     
#     # construct the full Z
#     random.levels <- sapply(seq_len(length(re.levels)), FUN=function(RX) {
#         rx.name <- names(re.levels)[RX]
#         paste(rx.name, seq_len(re.levels[[rx.name]]), sep="_")
#         }, simplify=FALSE)
#     names(random.levels) <- names(re.levels)
# 
#     full.Z <- initializeFullZ(Z, random.levels)
#     
#     # get a combination over random effects 
#     # and sample each level from the same ~Normal(0, sigma)
#     # note that the variance would be G if we also had random slopes
#     re.thetas <- list()
#     for(i in seq_len(length(re.levels))){
#         i.re <- names(random.levels[i])
#         i.levels <- length(random.levels[[i.re]])
#         i.re.means <- rnorm(n=i.levels, 0, sd=sqrt(re.sigmas[[i.re]])) # sample a random effect value
#         i.re.list <- sapply(seq_len(i.levels), FUN=function(X) i.re.means[X])
#         names(i.re.list) <- random.levels[[i.re]]
#         re.thetas[[i.re]] <- i.re.list
#     }
#     
#     unique.re.df <- as.data.frame(Z)
#     unique.re.df$B <- full.Z %*% unlist(re.thetas)
# 
#     # map the fixed effects to mean values
#     unique.fe.df <- as.data.frame(X)
#     unique.fe.df$Beta <- NA
#     
#     betas <- c(grand.mean, unlist(fe.betas))
#     X_new <- as.matrix(unique.fe.df[ ,1:3])
#     unique.fe.df$Beta <- X_new %*% betas
# 
#     i.error <- matrix(data = rnorm(N, mean=0, sd=0.001), ncol = 1)
#     
#     # construct the y.means equation, depending on desired distribution and FE/RE
#     y.means <- exp(unique.fe.df$Beta + unique.re.df$B) 
#     y.means <- y.means + i.error
# 
#     #theta.disp <- (mu.mu/2) - dispersion
#     #y.counts <- rnegbin(n=nrow(y.means), mu=exp(unique.fe.df$Beta), theta=1)
#     y.counts <- rnbinom(N, mu = y.means, size = dispersion)
# 
#     sim.data <- data.frame("Mean"=y.means, "Mean.Count"=y.counts)
#     sim.data <- do.call(cbind.data.frame, list(sim.data, X, Z))
#     
#     return(sim.data)
# }
# 
# fe.levels <- list("FE1"=2, "FE2"=1)
# re.levels <- list("RE1"=3, "RE2"=5)
# 
# grand.mean <- 2
# 
# fe.betas <- list("FE1"=0.03, "FE2"=0.08)
# re.sigmas <- list("RE1"=0.04, "RE2"=0.07)
# 
# r.dispersion <- 0.5
# set.seed(42)
# sim.df <- SimulateMMData(N=500, fe.betas=fe.betas, re.sigmas=re.sigmas, dispersion=r.dispersion, grand.mean=grand.mean, 
#                          n.fe=2, n.re=2, re.levels=re.levels, fe.levels=fe.levels)
# 
# sim.df$FE1 <- as.factor(sim.df$FE1)
# sim.df$RE1 <- as.factor(sim.df$RE1)
# sim.df$RE2 <- as.factor(sim.df$RE2)
# 
# head(sim.df)
```

By having this wrapped up in a function I can replicate it multiple times to get a series of simulations.

```{r, fig.height=2.55, fig.width=4.95}
sim.melt <- melt(sim.df, id.vars=c("Mean", "Mean.Count", "Intercept", "FE2"))

ggplot(sim.melt, aes(x=value, y=Mean.Count)) +
    geom_boxplot()  +
    theme_cowplot() +
    expand_limits(y=c(0)) + 
    facet_wrap(~variable, scales="free_x") +
    NULL
```

These show the relationship between the factor variables and the simulated counts.

```{r, fig.height=2.55}
ggplot(sim.df, aes(x=FE2, y=Mean.Count)) +
    geom_point() +
    theme_cowplot() +
    expand_limits(y=c(0)) +
    NULL
```

This shows the relationship between the continuous variables and the mean counts. With these data I will compare my implementation to glmmTMB and a straight-up 
ANOVA-mixed model.

## glmmTMB

```{r}
sim.df$RE3 <- runif(nrow(sim.df))
nb.glm <- glmmTMB(Mean.Count ~ 1 + FE1 + (1|RE1), data=sim.df, family=nbinom2(link="log"), REML=TRUE, se=TRUE)
summary(nb.glm)

cc <- coef(summary(nb.glm))

#fm1 <- mixed_model(fixed = Mean.Count ~ 1 + FE1 + FE2, random = ~ FE2|RE1, data = sim.df,
#                   family=negative.binomial())
#summary(fm1)
#glmer(Mean.Count ~ 1 + FE1 + FE2 + (FE1|RE1), family=nbinom2(link = "log"), data=sim.df) 
#glmmTMB:::Anova.glmmTMB(nb.glm)
#sqrt(diag(vcov(nb.glm,full=TRUE)))
#cc[["cond"]][,"Estimate"]/cc[["cond"]][,"Std. Error"]
```

## My model

```{r, warning=TRUE}
random.levels <- list("RE1"=paste("RE1", levels(as.factor(sim.df$RE1)), sep="_"), "RE2"=paste("RE2", levels(as.factor(sim.df$RE2)), sep="_"))
X <- as.matrix(data.frame("Intercept"=rep(1, nrow(sim.df)), "FE1"=as.numeric(sim.df$FE1)-1, "FE2"=as.numeric(sim.df$FE2)))
Z <- as.matrix(data.frame("RE1"=as.numeric(sim.df$RE1), "RE2"=as.numeric(sim.df$RE2)))
y <- sim.df$Mean.Count
dispersion <- 0.5

random.levels <- list("RE3"=paste("RE3", levels(as.factor(sim.df$RE3)), sep="_"))
X <- as.matrix(data.frame("Intercept"=rep(1, nrow(sim.df)), "FE1"=as.numeric(sim.df$FE1)-1, "FE2"=as.numeric(sim.df$FE2)))
Z <- as.matrix(data.frame("RE3"=as.numeric(sim.df$RE3)))
y <- sim.df$Mean.Count
dispersion <- 0.5

model.list <- miloR::runGLMM(X=X, Z=Z, y=y, random.levels=random.levels, REML = TRUE, dispersion=dispersion)
model.coef <- c(model.list$FE, model.list$Sigma)
```

```{r}
print("coefficients")
model.coef
print("SE")
model.list$SE
print("Zscore")
model.list$Zscore
print("pvalue")
model.list$pvalue
```

Above shows the coefficient and variance component estimates. We can evaluate the model a bit more by looking at the convergence and loglihood across iterations.

```{r}

diff.df <- melt(do.call(cbind,
                        lapply(conv.list, function(X){
                            x <- X$Theta.Diff
                            names(x) <- rownames(X$Theta.Diff)
                            x
                            })))
diff.df$Var2 <- rep(1:(max(as.numeric(names(model.list$Iterations)))), each = 12)
# likli.df <- do.call(rbind.data.frame,
#                     lapply(conv.list, function(X){
#                         X$Loglihood
#                         }))
# colnames(likli.df) <- c("Loglihood")
# likli.df$Iters <- seq_len(nrow(likli.df))

# full.logli.df <- do.call(rbind.data.frame,
#                     lapply(conv.list, function(X){
#                         X$Full.Loglihood
#                         }))
# colnames(full.logli.df) <- c("Full.Loglihood")
# full.logli.df$Iters <- seq_len(nrow(full.logli.df))


theta.df <- melt(do.call(cbind,
                        lapply(conv.list, function(X){
                            x <- X$Theta
                            names(x) <- rownames(X$Theta)
                            x
                            })))
theta.df$Var2 <- rep(1:(max(as.numeric(names(model.list$Iterations)))), each = 12)

variance.diff.df <- melt(do.call(cbind,
                        lapply(conv.list, function(X){
                            x <- X$Sigma.Diff
                            x
                            })))
variance.diff.df$Var2 <- rep(1:(max(as.numeric(names(model.list$Iterations)))), each = 1)

variance.df <- melt(do.call(cbind,
                        lapply(conv.list, function(X){
                            x <- X$Sigma
                            x
                            })))
variance.df$Var2 <- rep(1:(max(as.numeric(names(model.list$Iterations)))), each = 1)

# var.comp.df <- melt(do.call(cbind,
#                             lapply(conv.list, function(X){
#                                 x <- X$Var.Comps
#                                 names(x) <- c(names(random.levels), "residual")
#                                 x
#                                 })))

# diff.var.comp.df <- melt(do.call(cbind,
#                             lapply(conv.list, function(X){
#                                 x <- X$Var.Comp.Diff
#                                 names(x) <- c(names(random.levels), "residual")
#                                 x
#                                 })))
# diff.var.comp.df <- diff.var.comp.df[!is.na(diff.var.comp.df$Var1), ]
```

```{r}
theta.conv <- 1e-5

# ggplot(diff.df, aes(x=Var2, y=abs(value), colour=Var1)) +
#     # geom_point() +
#     geom_hline(yintercept=theta.conv, lty=2, col='red') +
#     geom_line() +
#     theme_cowplot() +
#     scale_colour_ptol() +
#     # scale_x_continuous(breaks=c(0:100)) +
#     labs(x="Iteration", y=expression(theta[0] - theta["t"])) +
#     facet_wrap(~Var1, scales="free_y") +
#     #scale_y_log10() +
#     # expand_limits(y=c(1e-8)) +
#     NULL

ggplot(diff.df, aes(x=Var2, y=abs(value), colour=Var1)) +
    # geom_point() +
    geom_hline(yintercept=theta.conv, lty=2, col='red') +
    geom_line() +
    theme_cowplot() +
    scale_colour_ptol() +
    # scale_x_continuous(breaks=c(0:100)) +
    labs(x="Iteration", y=expression(theta[0] - theta["t"])) +
    facet_wrap(~Var1, scales="free_y") +
    #scale_y_log10() +
    # expand_limits(y=c(1e-8)) +
    NULL

ggplot(variance.diff.df[2:nrow(variance.diff.df),], aes(x=Var2, y=abs(value), colour=Var1)) +
    # geom_point() +
    geom_hline(yintercept=theta.conv, lty=2, col='red') +
    geom_line() +
    theme_cowplot() +
    scale_colour_ptol() +
    # scale_x_continuous(breaks=c(0:100)) +
    labs(x="Iteration", y=expression(theta[0] - theta["t"])) +
    facet_wrap(~Var1, scales="free_y") +
    #scale_y_log10() +
    # expand_limits(y=c(1e-8)) +
    NULL
```

Currently these variance components sum to > total variance, and hence the residual variance is negative!!

```{r, fig.height=5.15, fig.width=10.95}
ggplot(theta.df, aes(x=Var2, y=value, colour=Var1, group=Var1)) +
    # geom_point() +
    geom_line() +
    theme_cowplot() +
    scale_colour_d3("category20c") +
    # scale_x_continuous(breaks=c(0:100)) +
    labs(x="Iteration", y=expression(theta["t"])) +
    facet_wrap(~Var1, scales="free_y") +
    # expand_limits(y=c(0)) +
    NULL

ggplot(variance.df, aes(x=Var2, y=(value), colour=Var1, group=Var1)) +
    # geom_point() +
    geom_line() +
    theme_cowplot() +
    scale_colour_d3("category20c") +
    # scale_x_continuous(breaks=c(0:100)) +
    labs(x="Iteration", y=expression(theta["t"])) +
    facet_wrap(~Var1, scales="free_y") +
    # expand_limits(y=c(0)) +
    NULL
```

Let's also plot the shape of the loglihood over the different parameter values for the variance components.

```{r, fig.height=3.15, fig.width=8.15}
var.loglihood.df <- merge(likli.df, var.comp.df, by.x='Iters', by.y='Var2')
colnames(var.loglihood.df) <- c("Iters", "Loglihood", "VarComp", "VarComp.value")
var.loglihood.df <- merge(var.loglihood.df, theta.df, by.x='Iters', by.y='Var2')

ggplot(var.loglihood.df, 
       aes(x=VarComp.value, y=Loglihood, colour=VarComp, group=Var1)) +
    # geom_point() +
    geom_line() +
    theme_cowplot() +
    scale_colour_npg() +
    # scale_x_continuous(breaks=c(0:100)) +
    labs(x="Param value", y="Loglihood") +
    facet_wrap(~VarComp, scales="free_x") +
    # expand_limits(y=c(0)) +
    NULL
```


```{r, fig.height=6.15, fig.width=8.15}
var.loglihood.df <- merge(full.logli.df, var.comp.df, by.x='Iters', by.y='Var2')
colnames(var.loglihood.df) <- c("Iters", "Loglihood", "VarComp", "VarComp.value")
var.loglihood.df <- merge(var.loglihood.df, theta.df, by.x='Iters', by.y='Var2')

ggplot(var.loglihood.df, 
       aes(x=value, y=Loglihood, colour=Var1, group=Var1)) +
    # geom_point() +
    geom_line() +
    theme_cowplot() +
    scale_colour_ptol() +
    # scale_x_continuous(breaks=c(0:100)) +
    labs(x="Param value", y="Loglihood") +
    facet_wrap(~Var1, scales="free_x") +
    # expand_limits(y=c(0)) +
    NULL
```

Without the Hessian for the variance components we can't estimate any SEs. If only one of the REs is included then the model can be quite unstable, however, 
this might just be how I've set up the simulations as much as the model being problematic.

Now I will need to create a run of simulations and run my GLMM on each of these.

```{r, warning=FALSE, message=FALSE}
runSim <- function(...){
    
    set.seed(43)

    fe.levels <- list("FE1"=2)
    re.levels <- list("RE1"=10)
    grand.mean <- 2
    
    fe.betas <- list("FE1"=0.25)
    n.fe <- length(fe.betas)
    re.sigmas <- list("RE1"=0.4)
    n.re <- length(re.sigmas)

    r.dispersion <- 0.5
    sim.df <- SimulateMMData(N=1000, fe.betas=fe.betas, re.sigmas=re.sigmas, dispersion=r.dispersion, grand.mean=grand.mean, 
                             n.fe=n.fe, n.re=n.re, re.levels=re.levels, fe.levels=fe.levels)
    return(sim.df)
}

n.sims <- 5
sim.list <- replicate(n.sims, runSim(), simplify=FALSE)
```

I've simulated 100 datasets with the same input parameters to get an indication of how well the model deals with this random variation. I have a feeling 
that th model might be a bit over-specified, therefore I'll only test 1 of the random effects at a time.

```{r, warning=FALSE, message=FALSE, error=FALSE}
glmmWrapper <- function(sim.df){

    random.levels <- list("RE1"=paste("RE1", levels(as.factor(sim.df$RE1)), sep="_"))
    X <- as.matrix(data.frame("Intercept"=rep(1, nrow(sim.df)), "FE1"=as.numeric(sim.df$FE1)))
    Z <- as.matrix(data.frame("RE1"=as.numeric(sim.df$RE1)))
    y <- sim.df$Mean.Count
    dispersion <- 0.5 #unique(sim.df$r)

    glmm.control <- glmmControl.defaults()
    glmm.control$theta.tol <- 1e-5
    glmm.control$max.iter <- 15

    try({
        i.start <- proc.time()
        model.list <- runGLMM(X=X, Z=Z, y=y, random.levels=random.levels, glmm.control=glmm.control, dispersion=dispersion)
        i.end <- proc.time()
        conv.list <- model.list$Iterations

        out.list <- list("coefficients"=c(model.list$FE, model.list$RE),
                         "sigma"=model.list$Sigma,
                         "iters"=model.list$Iters,
                         "converged"=model.list$converged,
                         "dispersion"=model.list$Dispersion,
                         "start"=i.start, "end"=i.end, "elapsed"=(i.end - i.start)[3])
        return(out.list)
        })
}

glmm.sim.list <- lapply(sim.list, glmmWrapper)
table(unlist(lapply(glmm.sim.list, class)))
# glmmWrapper(sim.list[[11]])
```

```{r, warning=FALSE, message=FALSE, fig.height=2.15, fig.width=4.15}
coeff <- lapply(glmm.sim.list, `[[`, 1)
sigma <- lapply(glmm.sim.list, `[[`, 2)

coeff_mat <- t(data.frame(matrix(unlist(coeff), nrow=12)))[,1:4]
coeff_mat <- data.frame(cbind(unlist(sigma), coeff_mat))
coeff_mat$iter <- 1:5
colnames(coeff_mat) <- c("sigma", "intercept", "beta", "b1", "b2", "iter")
coeff_pivoted <- pivot_longer(coeff_mat, cols = 1:5)

ggplot(coeff_pivoted, aes(x = iter, y = value, group = name)) +
    geom_line(aes(color = name)) +
    theme(text = element_text(size = 16)) +
    theme_bw() +
    NULL
```


```{r, warning=FALSE, message=FALSE, error=FALSE}
glmmWrapper <- function(sim.df, dispersion){

    random.levels <- list("RE1"=paste("RE1", levels(as.factor(sim.df$RE1)), sep="_"))
    X <- as.matrix(data.frame("Intercept"=rep(1, nrow(sim.df)), "FE1"=as.numeric(sim.df$FE1)))
    Z <- as.matrix(data.frame("RE1"=as.numeric(sim.df$RE1)))
    y <- sim.df$Mean.Count
    dispersion <- dispersion

    glmm.control <- glmmControl.defaults()
    glmm.control$theta.tol <- 1e-5
    glmm.control$max.iter <- 15

    try({
        i.start <- proc.time()
        model.list <- runGLMM(X=X, Z=Z, y=y, random.levels=random.levels, glmm.control=glmm.control, dispersion=dispersion)
        i.end <- proc.time()
        conv.list <- model.list$Iterations

        out.list <- list("coefficients"=c(model.list$FE, model.list$RE),
                         "sigma"=model.list$Sigma,
                         "iters"=model.list$Iters,
                         "converged"=model.list$converged,
                         "dispersion"=model.list$Dispersion,
                         "start"=i.start, "end"=i.end, "elapsed"=(i.end - i.start)[3])
        return(out.list)
        })
}
#seq(0.1, 1, 0.2)
glmm.sim.list <- c()
i <- 1
for (dispersion in seq(0.1, 1, 0.2)) { 
    glmm.sim.list[[i]] <- glmmWrapper(sim.list[[1]], dispersion)
    i <- i + 1
}
```

```{r, warning=FALSE, message=FALSE, fig.height=2.15, fig.width=4.15}
glmm.sim.list2 <- glmm.sim.list[c(1:5)]
coeff <- lapply(glmm.sim.list2, `[[`, 1)
sigma <- lapply(glmm.sim.list2, `[[`, 2)
r <- lapply(glmm.sim.list2, `[[`, 5)

coeff_mat <- t(data.frame(matrix(unlist(coeff), nrow=12)))[,1:2]
coeff_mat <- data.frame(cbind(unlist(sigma), coeff_mat))
coeff_mat$r <- unlist(r)

colnames(coeff_mat) <- c("sigma", "intercept", "beta", "r")
coeff_pivoted <- pivot_longer(coeff_mat, cols = 1:3)

ggplot(coeff_pivoted, aes(x = r, y = value, group = name)) +
    geom_point() +
    theme_bw() + 
    geom_line(aes(color = name)) +
    theme(text = element_text(size = 16)) +
    scale_x_continuous(breaks = seq(0.1, 1, 0.2)) +
    NULL
```

Next we are going to change one variable at a time and compare the predicted B, b and sigmas for the two versions of nb_glmm and TMB.
Firs we need to simulate the data. 

```{r, warning=FALSE, message=FALSE}
j <- 1
sim.list <- c()

for (i in seq(0.05, 0.7, 0.15)) {
    
    set.seed(43)
    fe.levels <- list("FE1"=2)
    re.levels <- list("RE1"=10)
    r.dispersion <- 0.5
    fe.betas=list("FE1"=0.25)
    re.sigmas=list("RE1"=i)
    grand.mean=2
    
    sim.list[[j]] <- SimulateMMData(N=1000, fe.betas=fe.betas, re.sigmas=re.sigmas, dispersion=r.dispersion, grand.mean=grand.mean,
                               n.fe=length(fe.betas), n.re=length(re.sigmas), re.levels=re.levels, fe.levels=fe.levels)
    j <- j + 1
}
names(sim.list) <- seq(0.05, 0.7, 0.15)
```

```{r, warning=FALSE, message=FALSE, error=FALSE}

glmmTMBWrapper <- function(sim.list) {
    nb.glm <- glmmTMB(Mean.Count ~ 1 + FE1  + (1|RE1), data=sim.list, family=nbinom2(link="log"), REML=FALSE, se=TRUE)
    var <- VarCorr(nb.glm)
    out.list <- list("coefficients"=c(nb.glm[["fit"]][["par"]][1:2]),
                     "sigma"=unlist(var$cond))
}
glmm.sim.list_TMB <- lapply(sim.list, glmmTMBWrapper)

glmmTMBWrapper2 <- function(sim.list) {
    nb.glm <- glmmTMB(Mean.Count ~ 1 + FE1  + (1|RE1), data=sim.list, family=nbinom2(link="log"), REML=TRUE, se=TRUE)
    var <- VarCorr(nb.glm)
    out.list <- list("coefficients"=c(nb.glm[["fit"]][["par"]][1:2]),
                     "sigma"=unlist(var$cond))
}
glmm.sim.list_TMB_REML <- lapply(sim.list, glmmTMBWrapper2)

glmmWrapper1 <- function(sim.df){
    random.levels <- list("RE1"=paste("RE1", levels(as.factor(sim.df$RE1)), sep="_"))
    X <- as.matrix(data.frame("Intercept"=rep(1, nrow(sim.df)), "FE1"=as.numeric(sim.df$FE1)))
    Z <- as.matrix(data.frame("RE1"=as.numeric(sim.df$RE1)))
    y <- sim.df$Mean.Count
    dispersion <- 0.5 #unique(sim.df$r)

    glmm.control <- glmmControl.defaults()
    glmm.control$theta.tol <- 1e-5
    glmm.control$max.iter <- 15

    try({
        model.list <- runGLMM(X=X, Z=Z, y=y, random.levels=random.levels, REML = FALSE, glmm.control=glmm.control, dispersion=dispersion)
        conv.list <- model.list$Iterations

        out.list <- list("coefficients"=c(model.list$FE, model.list$RE),
                         "sigma"=model.list$Sigma,
                         "iters"=model.list$Iters,
                         "converged"=model.list$converged)
        return(out.list)
        })
}
glmm.sim.list_1 <- lapply(sim.list, glmmWrapper1)

glmmWrapper2 <- function(sim.df){
    random.levels <- list("RE1"=paste("RE1", levels(as.factor(sim.df$RE1)), sep="_"))
    X <- as.matrix(data.frame("Intercept"=rep(1, nrow(sim.df)), "FE1"=as.numeric(sim.df$FE1)))
    Z <- as.matrix(data.frame("RE1"=as.numeric(sim.df$RE1)))
    y <- sim.df$Mean.Count
    dispersion <- 0.5 #unique(sim.df$r)

    glmm.control <- glmmControl.defaults()
    glmm.control$theta.tol <- 1e-5
    glmm.control$max.iter <- 15

    try({
        model.list <- runGLMM(X=X, Z=Z, y=y, random.levels=random.levels, REML = TRUE, glmm.control=glmm.control, dispersion=dispersion)
        conv.list <- model.list$Iterations

        out.list <- list("coefficients"=c(model.list$FE, model.list$RE),
                         "sigma"=model.list$Sigma,
                         "iters"=model.list$Iters,
                         "converged"=model.list$converged)
        return(out.list)
        })
}
glmm.sim.list_REML <- lapply(sim.list, glmmWrapper2)

# glmmWrapper2 <- function(sim.df){
# 
#     random.levels <- list("RE1"=paste("RE1", levels(as.factor(sim.df$RE1)), sep="_"))
#     X <- as.matrix(data.frame("Intercept"=rep(1, nrow(sim.df)), "FE1"=as.numeric(sim.df$FE1)))
#     Z <- as.matrix(data.frame("RE1"=as.numeric(sim.df$RE1)))
#     y <- sim.df$Mean.Count
#     dispersion <- unique(sim.df$r)
# 
#     glmm.control <- glmmControl.defaults()
#     glmm.control$theta.tol <- 1e-5
#     glmm.control$max.iter <- 15
# 
#     try({
#         model.list <- runGLMM(X=X, Z=Z, y=y, random.levels=random.levels, glmm.control=glmm.control, dispersion=dispersion)
#         conv.list <- model.list$Iterations
# 
#         out.list <- list("coefficients"=c(model.list$FE[1:2], model.list$RE),
#                          "sigma"=model.list$Sigma,
#                          "iters"=model.list$Iters,
#                          "converged"=model.list$converged)
#         return(out.list)
#         })
# }
#glmm.sim.list_2 <- lapply(sim.list, glmmWrapper2)
```

```{r, warning=FALSE, message=FALSE, fig.height=2.15, fig.width=4.15}
glmmTMB_res <- glmm.sim.list_TMB
coeff <- lapply(glmmTMB_res, `[[`, 1)
sigma <- lapply(glmmTMB_res, `[[`, 2)
intercept <- names(sim.list)
coeff_mat <- t(data.frame(matrix(unlist(coeff), nrow=2)))
coeff_mat <- data.frame(cbind(unlist(sigma), coeff_mat))
coeff_mat$intercept <- intercept
colnames(coeff_mat) <- c("sigma", "intercept", "beta", "true_value")
coeff_mat$analysis <- "TMB"
coeff_pivoted <- pivot_longer(coeff_mat, cols = 1:3)

glmmTMB_res <- glmm.sim.list_TMB_REML
coeff <- lapply(glmmTMB_res, `[[`, 1)
sigma <- lapply(glmmTMB_res, `[[`, 2)
intercept <- names(sim.list)
coeff_mat <- t(data.frame(matrix(unlist(coeff), nrow=2)))
coeff_mat <- data.frame(cbind(unlist(sigma), coeff_mat))
coeff_mat$intercept <- intercept
colnames(coeff_mat) <- c("sigma", "intercept", "beta", "true_value")
coeff_mat$analysis <- "TMB_REML"
coeff_pivoted2 <- pivot_longer(coeff_mat, cols = 1:3)

glmm1_res <- glmm.sim.list_1
coeff <- lapply(glmm1_res, `[[`, 1)
sigma <- lapply(glmm1_res, `[[`, 2)
coeff_mat <- t(data.frame(matrix(unlist(coeff), nrow=12)))[,1:2]
coeff_mat <- data.frame(cbind(unlist(sigma), coeff_mat))
coeff_mat$intercept <- intercept
colnames(coeff_mat) <- c("sigma", "intercept", "beta", "true_value")
coeff_mat$analysis <- "nb_glmm"
coeff_pivoted3 <- pivot_longer(coeff_mat, cols = 1:3)

glmm1_res <- glmm.sim.list_REML
coeff <- lapply(glmm1_res, `[[`, 1)
sigma <- lapply(glmm1_res, `[[`, 2)
coeff_mat <- t(data.frame(matrix(unlist(coeff), nrow=12)))[,1:2]
coeff_mat <- data.frame(cbind(unlist(sigma), coeff_mat))
coeff_mat$intercept <- intercept
colnames(coeff_mat) <- c("sigma", "intercept", "beta", "true_value")
coeff_mat$analysis <- "nb_glmm_REML"
coeff_pivoted4 <- pivot_longer(coeff_mat, cols = 1:3)

# glmm2_res <- glmm.sim.list_2
# coeff <- lapply(glmm2_res, `[[`, 1)
# sigma <- lapply(glmm2_res, `[[`, 2)
# coeff_mat <- t(data.frame(matrix(unlist(coeff), nrow=12)))[,1:2]
# coeff_mat <- data.frame(cbind(unlist(sigma), coeff_mat))
# coeff_mat$intercept <- intercept
# colnames(coeff_mat) <- c("sigma", "intercept", "beta", "true_value")
# coeff_mat$analysis <- "nb_glmm_-"
# coeff_pivoted3 <- pivot_longer(coeff_mat, cols = 1:3)

to_plot <- rbind.data.frame(coeff_pivoted, coeff_pivoted3, coeff_pivoted2, coeff_pivoted4)
to_plot_f <- dplyr::filter(to_plot, name =="sigma")

ggplot(to_plot_f, aes(y = value, x = true_value, group = analysis)) +
    geom_bar(stat = "identity", color = "black", position = position_dodge(), aes(fill=analysis)) +
    theme_bw() + 
    theme(text = element_text(size = 18)) +
    scale_y_continuous(limits = c(0, 0.8), breaks = seq(0.05, 0.7, 0.15), expand = c(0,0)) +
    scale_fill_brewer(palette="Blues") +
    NULL
```

Same as above, but looking at SE for the fixed effects. 

```{r, warning=FALSE, message=FALSE}
j <- 1
sim.list <- c()

for (i in seq(0.05, 1, 0.2)) {
    
    set.seed(43)
    fe.levels <- list("FE1"=2)
    re.levels <- list("RE1"=10)
    r.dispersion <- 0.5
    fe.betas=list("FE1"=i)
    re.sigmas=list("RE1"=0.4)
    grand.mean=2
    
    sim.list[[j]] <- SimulateMMData(N=1000, fe.betas=fe.betas, re.sigmas=re.sigmas, dispersion=r.dispersion, grand.mean=grand.mean,
                               n.fe=length(fe.betas), n.re=length(re.sigmas), re.levels=re.levels, fe.levels=fe.levels)
    j <- j + 1
}
names(sim.list) <- seq(0.05, 1, 0.2)
```

```{r, warning=FALSE, message=FALSE, error=FALSE}

glmmTMBWrapper <- function(sim.list) {
    nb.glm <- glmmTMB(Mean.Count ~ 1 + FE1  + (1|RE1), data=sim.list, family=nbinom2(link="log"), REML=FALSE, se=TRUE)
    var <- VarCorr(nb.glm)
    se <- sqrt(diag(vcov(nb.glm,full=TRUE)))
    out.list <- list("coefficients"=c(nb.glm[["fit"]]$parfull[1:2]),
                     "sigma"=unlist(var$cond),
                     "se"=unname(se[1:2]))
}
glmm.sim.list_TMB <- lapply(sim.list, glmmTMBWrapper)

glmmTMBWrapper2 <- function(sim.list) {
    nb.glm <- glmmTMB(Mean.Count ~ 1 + FE1  + (1|RE1), data=sim.list, family=nbinom2(link="log"), REML=TRUE, se=TRUE)
    var <- VarCorr(nb.glm)
    se <- sqrt(diag(vcov(nb.glm,full=TRUE)))
    out.list <- list("coefficients"=c(nb.glm[["fit"]]$parfull[1:2]),
                     "sigma"=unlist(var$cond),
                     "se"=unname(se[1:2]))
}
glmm.sim.list_TMB_REML <- lapply(sim.list, glmmTMBWrapper2)

glmmWrapper1 <- function(sim.df){
    random.levels <- list("RE1"=paste("RE1", levels(as.factor(sim.df$RE1)), sep="_"))
    X <- as.matrix(data.frame("Intercept"=rep(1, nrow(sim.df)), "FE1"=as.numeric(sim.df$FE1)))
    Z <- as.matrix(data.frame("RE1"=as.numeric(sim.df$RE1)))
    y <- sim.df$Mean.Count
    dispersion <- 0.5

    glmm.control <- glmmControl.defaults()
    glmm.control$theta.tol <- 1e-5
    glmm.control$max.iter <- 15

    try({
        model.list <- runGLMM(X=X, Z=Z, y=y, random.levels=random.levels, REML = FALSE, glmm.control=glmm.control, dispersion=dispersion)
        conv.list <- model.list$Iterations
        out.list <- list("coefficients"=c(model.list$FE, model.list$RE),
                         "sigma"=model.list$Sigma,
                         "iters"=model.list$Iters,
                         "converged"=model.list$converged, 
                         "se"=model.list$SE)
        return(out.list)
        })
}
glmm.sim.list_1 <- lapply(sim.list, glmmWrapper1)

glmmWrapper2 <- function(sim.df){
    random.levels <- list("RE1"=paste("RE1", levels(as.factor(sim.df$RE1)), sep="_"))
    X <- as.matrix(data.frame("Intercept"=rep(1, nrow(sim.df)), "FE1"=as.numeric(sim.df$FE1)))
    Z <- as.matrix(data.frame("RE1"=as.numeric(sim.df$RE1)))
    y <- sim.df$Mean.Count
    dispersion <- 0.5 #unique(sim.df$r)

    glmm.control <- glmmControl.defaults()
    glmm.control$theta.tol <- 1e-5
    glmm.control$max.iter <- 15

    try({
        model.list <- runGLMM(X=X, Z=Z, y=y, random.levels=random.levels, REML = TRUE, glmm.control=glmm.control, dispersion=dispersion)
        conv.list <- model.list$Iterations

        out.list <- list("coefficients"=c(model.list$FE, model.list$RE),
                         "sigma"=model.list$Sigma,
                         "iters"=model.list$Iters,
                         "converged"=model.list$converged,
                         "se"=model.list$SE)
        return(out.list)
        })
}
glmm.sim.list_REML <- lapply(sim.list, glmmWrapper2)
```

```{r, warning=FALSE, message=FALSE, fig.height=2.15, fig.width=4.15}
glmmTMB_res <- glmm.sim.list_TMB
coeff <- lapply(glmmTMB_res, `[[`, 1)
sigma <- lapply(glmmTMB_res, `[[`, 2)
se <- lapply(glmmTMB_res, `[[`, 3)
intercept <- names(sim.list)
coeff_mat <- t(data.frame(matrix(unlist(coeff), nrow=2)))
se_mat <- t(data.frame(matrix(unlist(se), nrow=2)))
coeff_mat <- data.frame(cbind(unlist(sigma), se_mat, coeff_mat))
coeff_mat$intercept <- intercept
colnames(coeff_mat) <- c("sigma", "se.int", "se.fe", "intercept", "beta", "true_value")
coeff_mat$analysis <- "TMB"
coeff_pivoted <- pivot_longer(coeff_mat, cols = 1:4)

glmmTMB_res <- glmm.sim.list_TMB_REML
coeff <- lapply(glmmTMB_res, `[[`, 1)
sigma <- lapply(glmmTMB_res, `[[`, 2)
se <- lapply(glmmTMB_res, `[[`, 3)
intercept <- names(sim.list)
coeff_mat <- t(data.frame(matrix(unlist(coeff), nrow=2)))
se_mat <- t(data.frame(matrix(unlist(se), nrow=2)))
coeff_mat <- data.frame(cbind(unlist(sigma), se_mat, coeff_mat))
coeff_mat$intercept <- intercept
colnames(coeff_mat) <- c("sigma", "se.int", "se.fe", "intercept", "beta", "true_value")
coeff_mat$analysis <- "TMB_REML"
coeff_pivoted2 <- pivot_longer(coeff_mat, cols = 1:4)

glmm1_res <- glmm.sim.list_1
coeff <- lapply(glmm1_res, `[[`, 1)
sigma <- lapply(glmm1_res, `[[`, 2)
se <- lapply(glmm1_res, `[[`, 5)
coeff_mat <- t(data.frame(matrix(unlist(coeff), nrow=12)))[,1:2]
se_mat <- t(data.frame(matrix(unlist(se), nrow=2)))
coeff_mat <- data.frame(cbind(unlist(sigma), se_mat, coeff_mat))
coeff_mat$intercept <- intercept
colnames(coeff_mat) <- c("sigma", "se.int", "se.fe", "intercept", "beta", "true_value")
coeff_mat$analysis <- "nb_glmm"
coeff_pivoted3 <- pivot_longer(coeff_mat, cols = 1:4)

glmm1_res <- glmm.sim.list_REML
coeff <- lapply(glmm1_res, `[[`, 1)
sigma <- lapply(glmm1_res, `[[`, 2)
se <- lapply(glmm1_res, `[[`, 5)
coeff_mat <- t(data.frame(matrix(unlist(coeff), nrow=12)))[,1:2]
se_mat <- t(data.frame(matrix(unlist(se), nrow=2)))
coeff_mat <- data.frame(cbind(unlist(sigma), se_mat, coeff_mat))
coeff_mat$intercept <- intercept
colnames(coeff_mat) <- c("sigma", "se.int", "se.fe", "intercept", "beta", "true_value")
coeff_mat$analysis <- "nb_glmm_REML"
coeff_pivoted4 <- pivot_longer(coeff_mat, cols = 1:4)

to_plot <- rbind.data.frame(coeff_pivoted, coeff_pivoted3, coeff_pivoted2, coeff_pivoted4)
to_plot_f <- dplyr::filter(to_plot, name =="se.int")

ggplot(to_plot_f, aes(y = value, x = true_value, group = analysis)) +
    geom_bar(stat = "identity", color = "black", position = position_dodge(), aes(fill=analysis)) +
    theme_bw() + 
    xlab("true value of slope") +
    ylab("SE of intercept") +
    theme(text = element_text(size = 18)) +
    scale_y_continuous(limits = c(0, 0.24), breaks = seq(0.05, 1, 0.2), expand = c(0,0)) +
    scale_fill_brewer(palette="Blues") +
    NULL
```

Same as above, looking at pvalues

```{r, warning=FALSE, message=FALSE}
j <- 1
sim.list <- c()

for (i in seq(0.05, 2, 0.4)) {
    
    set.seed(43)
    fe.levels <- list("FE1"=2)
    re.levels <- list("RE1"=10, "RE2"=5)
    r.dispersion <- 0.5
    fe.betas=list("FE1"=i)
    re.sigmas=list("RE1"=0.4, "RE2"=0.4)
    grand.mean=2
    
    sim.list[[j]] <- SimulateMMData(N=1000, fe.betas=fe.betas, re.sigmas=re.sigmas, dispersion=r.dispersion, grand.mean=grand.mean,
                               n.fe=length(fe.betas), n.re=length(re.sigmas), re.levels=re.levels, fe.levels=fe.levels)
    j <- j + 1
}
names(sim.list) <- seq(0.05, 2, 0.4)
```

```{r, warning=FALSE, message=FALSE, error=FALSE}

glmmTMBWrapper <- function(sim.list) {
    nb.glm <- glmmTMB(Mean.Count ~ 1 + FE1  + (1|RE1) + (1|RE2), data=sim.list, family=nbinom2(link="log"), REML=FALSE, se=TRUE)
    var <- VarCorr(nb.glm)
    se <- sqrt(diag(vcov(nb.glm,full=TRUE)))
    out.list <- list("coefficients"=c(nb.glm[["fit"]]$parfull[1:2]),
                     "sigma"=unlist(var$cond),
                     "pvalues"=coef(summary(nb.glm))$cond[,4])
}
glmm.sim.list_TMB <- lapply(sim.list, glmmTMBWrapper)

glmmTMBWrapper2 <- function(sim.list) {
    nb.glm <- glmmTMB(Mean.Count ~ 1 + FE1  + (1|RE1) + (1|RE2), data=sim.list, family=nbinom2(link="log"), REML=TRUE, se=TRUE)
    var <- VarCorr(nb.glm)
    se <- sqrt(diag(vcov(nb.glm,full=TRUE)))
    out.list <- list("coefficients"=c(nb.glm[["fit"]]$parfull[1:2]),
                     "sigma"=unlist(var$cond),
                     "pvalues"=coef(summary(nb.glm))$cond[,4])
}
glmm.sim.list_TMB_REML <- lapply(sim.list, glmmTMBWrapper2)

glmmWrapper1 <- function(sim.df){
    random.levels <- list("RE1"=paste("RE1", levels(as.factor(sim.df$RE1)), sep="_"), "RE2"=paste("RE2", levels(as.factor(sim.df$RE2)), sep="_"))
    X <- as.matrix(data.frame("Intercept"=rep(1, nrow(sim.df)), "FE1"=as.numeric(sim.df$FE1)))
    Z <- as.matrix(data.frame("RE1"=as.numeric(sim.df$RE1), "RE2"=as.numeric(sim.df$RE2)))
    y <- sim.df$Mean.Count
    dispersion <- 0.5

    glmm.control <- glmmControl.defaults()
    glmm.control$theta.tol <- 1e-5
    glmm.control$max.iter <- 15

    try({
        model.list <- runGLMM(X=X, Z=Z, y=y, random.levels=random.levels, REML = FALSE, glmm.control=glmm.control, dispersion=dispersion)
        conv.list <- model.list$Iterations
        out.list <- list("coefficients"=c(model.list$FE, model.list$RE),
                         "sigma"=model.list$Sigma,
                         "iters"=model.list$Iters,
                         "converged"=model.list$converged, 
                         "pvalues"=model.list$Pvalue)
        return(out.list)
        })
}
glmm.sim.list_1 <- lapply(sim.list, glmmWrapper1)

glmmWrapper2 <- function(sim.df){
    random.levels <- list("RE1"=paste("RE1", levels(as.factor(sim.df$RE1)), sep="_"), "RE2"=paste("RE2", levels(as.factor(sim.df$RE2)), sep="_"))
    X <- as.matrix(data.frame("Intercept"=rep(1, nrow(sim.df)), "FE1"=as.numeric(sim.df$FE1)))
    Z <- as.matrix(data.frame("RE1"=as.numeric(sim.df$RE1), "RE2"=as.numeric(sim.df$RE2)))
    y <- sim.df$Mean.Count
    dispersion <- 0.5 #unique(sim.df$r)

    glmm.control <- glmmControl.defaults()
    glmm.control$theta.tol <- 1e-5
    glmm.control$max.iter <- 15

    try({
        model.list <- runGLMM(X=X, Z=Z, y=y, random.levels=random.levels, REML = TRUE, glmm.control=glmm.control, dispersion=dispersion)
        conv.list <- model.list$Iterations

        out.list <- list("coefficients"=c(model.list$FE, model.list$RE),
                         "sigma"=model.list$Sigma,
                         "iters"=model.list$Iters,
                         "converged"=model.list$converged,
                         "pvalues"=model.list$Pvalue)
        return(out.list)
        })
}
glmm.sim.list_REML <- lapply(sim.list, glmmWrapper2)
```

```{r, warning=FALSE, message=FALSE, fig.height=2.15, fig.width=4.15}
glmmTMB_res <- glmm.sim.list_TMB
coeff <- lapply(glmmTMB_res, `[[`, 1)
sigma <- lapply(glmmTMB_res, `[[`, 2)
se <- lapply(glmmTMB_res, `[[`, 3)
intercept <- names(sim.list)
coeff_mat <- t(data.frame(matrix(unlist(coeff), nrow=2)))
se_mat <- t(data.frame(matrix(unlist(se), nrow=2)))
coeff_mat <- data.frame(cbind(unlist(sigma), se_mat, coeff_mat))
coeff_mat$intercept <- intercept
colnames(coeff_mat) <- c("sigma", "pval.int", "pval.fe", "intercept", "beta", "true_value")
coeff_mat$analysis <- "TMB"
coeff_pivoted <- pivot_longer(coeff_mat, cols = 1:4)

glmmTMB_res <- glmm.sim.list_TMB_REML
coeff <- lapply(glmmTMB_res, `[[`, 1)
sigma <- lapply(glmmTMB_res, `[[`, 2)
se <- lapply(glmmTMB_res, `[[`, 3)
intercept <- names(sim.list)
coeff_mat <- t(data.frame(matrix(unlist(coeff), nrow=2)))
se_mat <- t(data.frame(matrix(unlist(se), nrow=2)))
coeff_mat <- data.frame(cbind(unlist(sigma), se_mat, coeff_mat))
coeff_mat$intercept <- intercept
colnames(coeff_mat) <- c("sigma", "pval.int", "pval.fe", "intercept", "beta", "true_value")
coeff_mat$analysis <- "TMB_REML"
coeff_pivoted2 <- pivot_longer(coeff_mat, cols = 1:4)

glmm1_res <- glmm.sim.list_1
coeff <- lapply(glmm1_res, `[[`, 1)
sigma <- lapply(glmm1_res, `[[`, 2)
se <- lapply(glmm1_res, `[[`, 5)
coeff_mat <- t(data.frame(matrix(unlist(coeff), nrow=17)))[,1:2]
se_mat <- t(data.frame(matrix(unlist(se), nrow=2)))
coeff_mat <- data.frame(cbind(unlist(sigma), se_mat, coeff_mat))
coeff_mat$intercept <- intercept
colnames(coeff_mat) <- c("sigma", "pval.int", "pval.fe", "intercept", "beta", "true_value")
coeff_mat$analysis <- "nb_glmm"
coeff_pivoted3 <- pivot_longer(coeff_mat, cols = 1:4)

glmm1_res <- glmm.sim.list_REML
coeff <- lapply(glmm1_res, `[[`, 1)
sigma <- lapply(glmm1_res, `[[`, 2)
se <- lapply(glmm1_res, `[[`, 5)
coeff_mat <- t(data.frame(matrix(unlist(coeff), nrow=17)))[,1:2]
se_mat <- t(data.frame(matrix(unlist(se), nrow=2)))
coeff_mat <- data.frame(cbind(unlist(sigma), se_mat, coeff_mat))
coeff_mat$intercept <- intercept
colnames(coeff_mat) <- c("sigma", "pval.int", "pval.fe", "intercept", "beta", "true_value")
coeff_mat$analysis <- "nb_glmm_REML"
coeff_pivoted4 <- pivot_longer(coeff_mat, cols = 1:4)

to_plot <- rbind.data.frame(coeff_pivoted, coeff_pivoted3, coeff_pivoted2, coeff_pivoted4)
to_plot_f <- dplyr::filter(to_plot, name =="pval.fe")

ggplot(to_plot_f, aes(y = value, x = true_value, group = analysis)) +
    geom_bar(stat = "identity", color = "black", position = position_dodge(), aes(fill=analysis)) +
    theme_bw() + 
    xlab("true value of slope") +
    ylab("pvalue of intercept") +
    theme(text = element_text(size = 18)) +
    #scale_y_continuous(limits = c(0, 5e-20), expand = c(0,0)) +
    scale_fill_brewer(palette="Blues") +
    NULL
```

```{r}
nb.glm <- glmmTMB(Mean.Count ~ 1 + FE1 + (1|RE1), data=sim.df, family=nbinom2(link="log"), REML=TRUE, se=TRUE)
summary(nb.glm)
runGLMM()
lmer()
```

